# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19M-y9GIoJhkfRX_DSiBgoF_ZNki6R1wB
"""

from google.colab import drive
drive.mount( '/content/drive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

path ="/content/drive/MyDrive/Cars_data.csv"
cars = pd.read_csv(path)

# Standardization of column headers
cars.columns = (
    cars.columns
    .str.strip()
    .str.lower()
    .str.replace(' ', '_')
    .str.replace('-', '_')
)

print(cars.head(10))

# Step 2: Replace blanks/invalid entries with appropriate values

# Define placeholders to replace
placeholders = ['', 'NA', 'None', '-']

# Replace blanks in 'engine_fuel_type' with 'hybrid'
cars['engine_fuel_type'] = cars['engine_fuel_type'].replace(placeholders, 'hybrid')

# Replace blanks in 'engine_hp' with 0
cars['engine_hp'] = cars['engine_hp'].replace(placeholders, np.nan).fillna(0)

# Replace blanks in 'number_of_doors' with 4
cars['number_of_doors'] = cars['number_of_doors'].replace(placeholders, np.nan).fillna(4)

# Replace blanks in 'engine_cylinders' with most frequent value per 'make'
# First, replace placeholders with NaN
cars['engine_cylinders'] = cars['engine_cylinders'].replace(placeholders, np.nan)

# Now, fill NaN values with most frequent value within each 'make'
cars['engine_cylinders'] = cars.groupby('make')['engine_cylinders'].transform(
    lambda x: x.fillna(x.mode().iloc[0]) if not x.mode().empty else x.fillna(0)
)
# Replace NaN values in 'market_category' with 'unknown'
cars['market_category'] = cars['market_category'].fillna('unknown')

# Replace NaN values in 'engine_fuel_type' with 'unknown'
cars['engine_fuel_type'] = cars['engine_fuel_type'].fillna('unknown')

# Count empty strings ('') in each column
empty_string_count = (cars == '').sum()

# Count NaN values in each column
nan_count = cars.isnull().sum()

# Combine both counts into one DataFrame for clarity
blanks_and_nans = pd.DataFrame({
    'empty_strings': empty_string_count,
    'NaNs': nan_count
})

# View the counts
print(blanks_and_nans)

# Converting 'model' column to string dtype
cars['model'] = cars['model'].astype('string')

# Converting specific columns to integer
# List of target columns to convert
int_columns = [
    'engine_hp',
    'engine_cylinders',
    'number_of_doors',
    'highway_mpg',
    'city_mpg',
    'popularity',
    'msrp'
]

# Converting each column to integer safely
for col in int_columns:
    cars[col] = cars[col].astype('Int64')  # 'Int64' supports missing values

#  Checking dtypes to confirm
print(cars.dtypes)

# cars.shape
# cars.index
cars.columns
# cars.info

# List of numeric columns
numeric_cols = ['engine_hp', 'engine_cylinders', 'number_of_doors',
                'highway_mpg', 'city_mpg', 'msrp']

# Set figure size for multiple plots
plt.figure(figsize=(18, 20))

# Loop through each numeric column and plot top 10 most frequent values
for idx, col in enumerate(numeric_cols):
    plt.subplot(4, 2, idx+1)
    value_counts = cars[col].value_counts().head(10)
    sns.barplot(x=value_counts.index, y=value_counts.values, palette='viridis')
    plt.title(f'Most Common Values in {col}')
    plt.xlabel(col)
    plt.ylabel('Count')
    plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

# Outlier detection
continuous_columns = ['msrp', 'engine_hp', 'city_mpg', 'highway_mpg']

for col in continuous_columns:
    plt.figure(figsize=(8, 4))
    sns.boxplot(x=cars[col])
    plt.title(f'Boxplot for {col}')
    plt.show()

# Histogram analysis
cars[continuous_columns].hist(figsize=(12, 8))
plt.tight_layout()
plt.show()

# Correlation heatmap
sns.heatmap(cars[continuous_columns].corr(), annot=True, cmap='coolwarm')
plt.title("Correlation Heatmap")
plt.show()

# Due to the extreme right skewness, normalization was performed
cars['log_msrp'] = np.log1p(cars['msrp'])

# Select the continuous columns
columns = ['engine_hp', 'highway_mpg', 'city_mpg', 'msrp']

# Calculate mean
mean_values = cars[columns].mean()

# Calculate median
median_values = cars[columns].median()

# Calculate mode (may have multiple values â€” returns DataFrame)
mode_values = cars[columns].mode()

# Print results
print("Mean values:\n", mean_values)
print("\nMedian values:\n", median_values)
print("\nMode values:\n", mode_values)